// Code generated by mtgroup-generator.
package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"flag"
	"fmt"
	"net"
	"os"
	"time"
	"wash-bonus/internal/app"
	"wash-bonus/internal/app/Balance"
	"wash-bonus/internal/app/user"
	"wash-bonus/internal/app/wash_server"
	"wash-bonus/internal/dal"
	"wash-bonus/internal/def"
	"wash-bonus/internal/firebase_auth"
	grpc3 "wash-bonus/internal/transport/grpc"
	api "wash-bonus/internal/transport/rest"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"

	"github.com/powerman/pqx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	connectTimeout = 3 * time.Second
)

var (
	testRepo *dal.Repo
	testAppl app.App

	log = structlog.New()
	cfg struct {
		logLevel string
		gooseDir string
		db       pqx.Config
		api      api.Config
		resetDB  bool
	}
)

func init() {
	var dbSSLModeRequire bool

	flag.BoolVar(&dbSSLModeRequire, "db.ssl-mode-is-req", def.DBSSLModeIsReq, "PostgreSQL SSL mode")

	if dbSSLModeRequire {
		cfg.db.SSLMode = pqx.SSLRequire
	} else {
		cfg.db.SSLMode = pqx.SSLDisable
	}
	flag.StringVar(&cfg.logLevel, "log.level", "debug", "log `level` (debug|info|warn|err)")

	flag.StringVar(&cfg.gooseDir, "goose.dir", def.GooseDir, "goose migrations `dir`")
	flag.StringVar(&cfg.db.Host, "db.host", def.DBHost, "PostgreSQL `host`")
	flag.IntVar(&cfg.db.Port, "db.port", def.DBPort, "PostgreSQL `port`")
	flag.StringVar(&cfg.db.User, "db.user", def.DBUser, "PostgreSQL `user`")
	flag.StringVar(&cfg.db.Pass, "db.pass", def.DBPass, "PostgreSQL `pass`")
	flag.StringVar(&cfg.db.DBName, "db.name", def.DBName, "PostgreSQL `dbname`")
	flag.BoolVar(&cfg.resetDB, "db.reset", def.ResetDB, "reset database if true")

	flag.StringVar(&cfg.api.Host, "api.host", def.APIHost, "serve API on `host`")
	flag.IntVar(&cfg.api.Port, "api.port", def.APIPort, "serve API on `port` (>0)")
	flag.StringVar(&cfg.api.BasePath, "api.basepath", def.APIBasePath, "serve API on `path`")
	flag.StringVar(&cfg.api.AllowedOrigins, "api.allow-origins", def.CORSAllowedOrigins, "frontend url")

}

func main() {
	flag.Parse()
	structlog.DefaultLogger.SetLogLevel(structlog.ParseLevel(cfg.logLevel))

	err := run()
	if err != nil {
		log.Fatal(err)
	}
}

func initDal() (*dal.Repo, error) {
	ctx, cancel := context.WithTimeout(context.Background(), connectTimeout)
	defer cancel()

	r, err := dal.New(ctx, cfg.db, cfg.gooseDir, cfg.resetDB)
	if err != nil {
		return nil, err
	}

	return r, nil
}

func run() error {
	log.Info("server started")
	defer log.Info("server finished")

	r, err := initDal()
	if err != nil {
		return err
	}
	washServerGRPCSvc, err := grpc3.NewWashServerService(r)
	if err != nil {
		return err
	}

	appl := app.New(r)
	userSvc := user.NewService(r)

	BalanceSvc := Balance.NewService(r)

	washServerSvc, err := wash_server.NewService(r, userSvc, washServerGRPCSvc.WashServerConnections,
		def.WashServerRSAPrivateKeyFilePath, def.WashServerRSAPublicKeyFilePath)
	if err != nil {
		return err
	}

	firebase := firebase_auth.New(def.FirebaseKeyFilePath)

	errc := make(chan error)

	go runGRPCServer(errc, washServerGRPCSvc, def.GRPCEnableTLS)
	go runHTTPServer(errc, appl, userSvc, BalanceSvc, washServerSvc, firebase)

	return <-errc
}

func loadTLSCredentials() (credentials.TransportCredentials, error) {
	pemClientCA, err := os.ReadFile(def.ClientCACertFile)
	if err != nil {
		return nil, err
	}

	certPool := x509.NewCertPool()
	if !certPool.AppendCertsFromPEM(pemClientCA) {
		return nil, fmt.Errorf("failed to add client CA's certificate")
	}

	// Load server's certificate and private key
	serverCert, err := tls.LoadX509KeyPair(def.ServerCertFile, def.ServerKeyFile)
	if err != nil {
		return nil, err
	}

	return credentials.NewTLS(&tls.Config{
		Certificates: []tls.Certificate{serverCert},
		ClientAuth:   tls.NoClientCert,
		ClientCAs:    certPool,
	}), nil
}

func runGRPCServer(errc chan<- error, WashServerGRPCService *grpc3.WashServerService, enableTLS bool) {
	serverOptions := []grpc.ServerOption{}

	if enableTLS {
		credentialsTLS, err := loadTLSCredentials()
		if err != nil {
			errc <- fmt.Errorf("grpc: %v", err)
			return
		}
		serverOptions = append(serverOptions, grpc.Creds(credentialsTLS))
	}

	server := grpc.NewServer(serverOptions...)

	grpc3.RegisterWashServerServiceServer(server, WashServerGRPCService)

	l, err := net.Listen("tcp", ":"+def.GRPCPort)
	if err != nil {
		errc <- fmt.Errorf("grpc: %v", err)
		return
	}

	errc <- server.Serve(l)
}

func runHTTPServer(errc chan<- error, appl app.App, userSvc user.UserSvc, Balance Balance.BalanceSvc, washServerSvc wash_server.WashServerSvc, firebase firebase_auth.Service) {
	srv, err := api.NewServer(appl, userSvc, Balance, washServerSvc, cfg.api, firebase)
	if err != nil {
		errc <- fmt.Errorf("api: %v", err)
		return
	}

	errc <- srv.Serve()
}
